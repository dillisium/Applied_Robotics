// Generated by gencpp from file a2_msgs/UKDState.msg
// DO NOT EDIT!


#ifndef A2_MSGS_MESSAGE_UKDSTATE_H
#define A2_MSGS_MESSAGE_UKDSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace a2_msgs
{
template <class ContainerAllocator>
struct UKDState_
{
  typedef UKDState_<ContainerAllocator> Type;

  UKDState_()
    : header()
    , tx(0.0)
    , ty(0.0)
    , tz(0.0)
    , ta(0.0)
    , to(0.0)
    , tp(0.0)
    , td(0.0)
    , t_roll(0.0)
    , t_pitch(0.0)
    , t_yaw(0.0)
    , t_valid(0)
    , est_suc_count(0)
    , rocker0_x(0.0)
    , rocker0_y(0.0)
    , button0(0)
    , button1(0)
    , button2(0)
    , button3(0)
    , buttons_mode(0)
    , joy_mode(0)  {
    }
  UKDState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , tx(0.0)
    , ty(0.0)
    , tz(0.0)
    , ta(0.0)
    , to(0.0)
    , tp(0.0)
    , td(0.0)
    , t_roll(0.0)
    , t_pitch(0.0)
    , t_yaw(0.0)
    , t_valid(0)
    , est_suc_count(0)
    , rocker0_x(0.0)
    , rocker0_y(0.0)
    , button0(0)
    , button1(0)
    , button2(0)
    , button3(0)
    , buttons_mode(0)
    , joy_mode(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef float _tx_type;
  _tx_type tx;

   typedef float _ty_type;
  _ty_type ty;

   typedef float _tz_type;
  _tz_type tz;

   typedef float _ta_type;
  _ta_type ta;

   typedef float _to_type;
  _to_type to;

   typedef float _tp_type;
  _tp_type tp;

   typedef float _td_type;
  _td_type td;

   typedef float _t_roll_type;
  _t_roll_type t_roll;

   typedef float _t_pitch_type;
  _t_pitch_type t_pitch;

   typedef float _t_yaw_type;
  _t_yaw_type t_yaw;

   typedef uint8_t _t_valid_type;
  _t_valid_type t_valid;

   typedef uint16_t _est_suc_count_type;
  _est_suc_count_type est_suc_count;

   typedef float _rocker0_x_type;
  _rocker0_x_type rocker0_x;

   typedef float _rocker0_y_type;
  _rocker0_y_type rocker0_y;

   typedef int8_t _button0_type;
  _button0_type button0;

   typedef int8_t _button1_type;
  _button1_type button1;

   typedef int8_t _button2_type;
  _button2_type button2;

   typedef int8_t _button3_type;
  _button3_type button3;

   typedef int8_t _buttons_mode_type;
  _buttons_mode_type buttons_mode;

   typedef int8_t _joy_mode_type;
  _joy_mode_type joy_mode;





  typedef boost::shared_ptr< ::a2_msgs::UKDState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::a2_msgs::UKDState_<ContainerAllocator> const> ConstPtr;

}; // struct UKDState_

typedef ::a2_msgs::UKDState_<std::allocator<void> > UKDState;

typedef boost::shared_ptr< ::a2_msgs::UKDState > UKDStatePtr;
typedef boost::shared_ptr< ::a2_msgs::UKDState const> UKDStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::a2_msgs::UKDState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::a2_msgs::UKDState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::a2_msgs::UKDState_<ContainerAllocator1> & lhs, const ::a2_msgs::UKDState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.tx == rhs.tx &&
    lhs.ty == rhs.ty &&
    lhs.tz == rhs.tz &&
    lhs.ta == rhs.ta &&
    lhs.to == rhs.to &&
    lhs.tp == rhs.tp &&
    lhs.td == rhs.td &&
    lhs.t_roll == rhs.t_roll &&
    lhs.t_pitch == rhs.t_pitch &&
    lhs.t_yaw == rhs.t_yaw &&
    lhs.t_valid == rhs.t_valid &&
    lhs.est_suc_count == rhs.est_suc_count &&
    lhs.rocker0_x == rhs.rocker0_x &&
    lhs.rocker0_y == rhs.rocker0_y &&
    lhs.button0 == rhs.button0 &&
    lhs.button1 == rhs.button1 &&
    lhs.button2 == rhs.button2 &&
    lhs.button3 == rhs.button3 &&
    lhs.buttons_mode == rhs.buttons_mode &&
    lhs.joy_mode == rhs.joy_mode;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::a2_msgs::UKDState_<ContainerAllocator1> & lhs, const ::a2_msgs::UKDState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace a2_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::a2_msgs::UKDState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::a2_msgs::UKDState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::a2_msgs::UKDState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::a2_msgs::UKDState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::a2_msgs::UKDState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::a2_msgs::UKDState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::a2_msgs::UKDState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "f226fa6e72173f2731bf809458ac94af";
  }

  static const char* value(const ::a2_msgs::UKDState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xf226fa6e72173f27ULL;
  static const uint64_t static_value2 = 0x31bf809458ac94afULL;
};

template<class ContainerAllocator>
struct DataType< ::a2_msgs::UKDState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "a2_msgs/UKDState";
  }

  static const char* value(const ::a2_msgs::UKDState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::a2_msgs::UKDState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"# UWB标签在基站坐标系下的位姿（欧几里得坐标系）\n"
"float32 tx\n"
"float32 ty\n"
"float32 tz\n"
"float32 ta\n"
"\n"
"# UWB标签在基站坐标系下的位姿（圆柱坐标系）方位角, 俯仰角, 距离\n"
"float32 to \n"
"float32 tp\n"
"float32 td\n"
"\n"
"# 标签IMU的原始roll、pitch和yaw值\n"
"float32 t_roll\n"
"float32 t_pitch\n"
"float32 t_yaw\n"
"\n"
"# 当前次位姿估计的有效性标志: 0-无效; 1-有效\n"
"uint8 t_valid\n"
"\n"
"# 位姿估计连续成功的次数\n"
"uint16 est_suc_count\n"
"\n"
"# 标签摇杆的值\n"
"float32 rocker0_x\n"
"float32 rocker0_y\n"
"\n"
"# 标签按键的原始值\n"
"int8 button0\n"
"int8 button1\n"
"int8 button2\n"
"int8 button3\n"
"\n"
"# 标签按键的联合解析值\n"
"int8 buttons_mode\n"
"\n"
"# joy mode\n"
"int8 joy_mode\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::a2_msgs::UKDState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::a2_msgs::UKDState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.tx);
      stream.next(m.ty);
      stream.next(m.tz);
      stream.next(m.ta);
      stream.next(m.to);
      stream.next(m.tp);
      stream.next(m.td);
      stream.next(m.t_roll);
      stream.next(m.t_pitch);
      stream.next(m.t_yaw);
      stream.next(m.t_valid);
      stream.next(m.est_suc_count);
      stream.next(m.rocker0_x);
      stream.next(m.rocker0_y);
      stream.next(m.button0);
      stream.next(m.button1);
      stream.next(m.button2);
      stream.next(m.button3);
      stream.next(m.buttons_mode);
      stream.next(m.joy_mode);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct UKDState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::a2_msgs::UKDState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::a2_msgs::UKDState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "tx: ";
    Printer<float>::stream(s, indent + "  ", v.tx);
    s << indent << "ty: ";
    Printer<float>::stream(s, indent + "  ", v.ty);
    s << indent << "tz: ";
    Printer<float>::stream(s, indent + "  ", v.tz);
    s << indent << "ta: ";
    Printer<float>::stream(s, indent + "  ", v.ta);
    s << indent << "to: ";
    Printer<float>::stream(s, indent + "  ", v.to);
    s << indent << "tp: ";
    Printer<float>::stream(s, indent + "  ", v.tp);
    s << indent << "td: ";
    Printer<float>::stream(s, indent + "  ", v.td);
    s << indent << "t_roll: ";
    Printer<float>::stream(s, indent + "  ", v.t_roll);
    s << indent << "t_pitch: ";
    Printer<float>::stream(s, indent + "  ", v.t_pitch);
    s << indent << "t_yaw: ";
    Printer<float>::stream(s, indent + "  ", v.t_yaw);
    s << indent << "t_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.t_valid);
    s << indent << "est_suc_count: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.est_suc_count);
    s << indent << "rocker0_x: ";
    Printer<float>::stream(s, indent + "  ", v.rocker0_x);
    s << indent << "rocker0_y: ";
    Printer<float>::stream(s, indent + "  ", v.rocker0_y);
    s << indent << "button0: ";
    Printer<int8_t>::stream(s, indent + "  ", v.button0);
    s << indent << "button1: ";
    Printer<int8_t>::stream(s, indent + "  ", v.button1);
    s << indent << "button2: ";
    Printer<int8_t>::stream(s, indent + "  ", v.button2);
    s << indent << "button3: ";
    Printer<int8_t>::stream(s, indent + "  ", v.button3);
    s << indent << "buttons_mode: ";
    Printer<int8_t>::stream(s, indent + "  ", v.buttons_mode);
    s << indent << "joy_mode: ";
    Printer<int8_t>::stream(s, indent + "  ", v.joy_mode);
  }
};

} // namespace message_operations
} // namespace ros

#endif // A2_MSGS_MESSAGE_UKDSTATE_H
